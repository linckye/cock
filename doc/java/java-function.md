# JavaFunction

*JavaFunction*为*Function*在Java上的实现，主要职责为对用户上传的Java代码或者可运行jar包进行执行。

## 解决方案

### Java代码

对于上传Java代码的应用场景，无非是类似脚本执行，而Java没有作为脚本语言的特性，在开发上就存在效率问题，不实际，所以暂时不予实现。

### 可运行jar包

> 首先需要解决的疑惑是为什么是jar，而不是war或者ear（具体含义区别请百度）？
> * 第一点是war和ear太重，Web应用和企业级应用生命周期太长，多数启动后就不会结束，和任务的概念不太契合。
> * 第二点是部署的简易性，war依赖于Servlet容器，ear依赖于EJB容器，这两者在部署的时候都需要特定的环境。而jar可以通过命令*java -jar*便可执行，入参也是通过命令指定。

#### 检查

对jar包的检查，在上传时就应该进行，主要的内容有是否可运行、是否指定Main-Class、类依赖是否缺失等等。

#### 运行

对于如何运行jar包，有两种方式: 

1.  通过类加载的方式。将jar中的类加载到任务执行器自己的JVM中，通过解析*MANIFEST.MF*文件找到*Main-Class*并执行main方法从而运行jar。这种方式可能会带来类冲突问题，而且在*MANIFEST.MF*文件的解析上需要花费很大的功夫。

2.  通过*java -jar*命令执行。这种方式上面有讲过，网上查找的资料多数也是通过这种方式，不足的是该方式可控性差，需要另起JVM，不在控制下，无法对检查运行过程的正确与否。不过解决方法还是有的，一种可通过*javaagent*设定JVM级别代理，主动地实现任务的监控，另外一种是提供SPI，由用户来实现需要进行监控的点，通过monitor-client来与任务执行器进行通讯。

#### 输入

参数的形式可能有两种，一种是main方法的args，另外一种是系统属性。在使用命令指定jar包后，紧接着的便是args的输入，传给main方法进行使用。而系统属性是通过-D\<param\>来指定。入参也有可能以文件的形式出现，例如外部配置文件等，而实际上文件的使用也是通过上面两种方式来指定路劲，我们要做的使得程序能够获取到文件，所以需要对文件进行统一管理，定制映射机制等。

#### 监控

之前讲到的监控方式有两种，一个javaagent，一个是SPI。javaagent可以达到毫无代码入侵的效果，但是无法达到细粒度的监控。虽然SPI可以完成这一要求，但是会增加用户的开发成本。最好的方式还是中西药结合，使用javaagent为基，SPI为细。

#### 输出

对于程序运行的产出更多的是log信息，可使用开源的日志管理平台进行收集。

